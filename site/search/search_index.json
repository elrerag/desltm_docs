{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"uml/lectura/","text":"Lectura Cap\u00edtulo 1: Introducci\u00f3n. Competencias esperadas: Conocer el lenguaje de modelado unificado (UML). Conocer los distintos tipos de diagramas. Glosario del cap\u00edtulo: Notaci\u00f3n : Es la acci\u00f3n y efecto de notar, hace referencia al sistema de signos convencionales que se adopta, para expresar alg\u00fan concepto. Metodolog\u00eda : Grupo de mecanismos o procedimientos racionales, empleados para el logro de un objetivo. Paradigma : Teor\u00eda o conjunto de teor\u00edas, cuyo n\u00facleo central se acepta sin cuestionar y que suministra la base y modelo para resolver problemas y avanzar en el conocimiento Software : Conjunto de programas, instrucciones y reglas inform\u00e1ticas que permiten ejecutar distintas tareas en una computadora. Programaci\u00f3n Imperativa : En este paradigma de la programaci\u00f3n, que, como su nombre lo indica, imperan las instrucciones, condiciones o pasos indicamos exactamente, lo que el programa debe hacer. T\u00edpicamente nos encontraremos con estructuras c\u00edclicas tales como: while, for. Tambi\u00e9n condicionales if o switch. Lo que no quiere decir que si un programa posee estas instrucciones es puramente imperativo. Podemos reconocer este tipo de programaci\u00f3n cuando leemos el c\u00f3digo y su traza es una interpretaci\u00f3n de lectura secuencial de lo que est\u00e1 escrito. Programaci\u00f3n procedural : Se trata de un estilo de programaci\u00f3n; basado en estructurar el c\u00f3digo de un programa en componentes, que reciben el nombre de procedimientos, subrutinas o funciones. Programaci\u00f3n Orientada a Objetos (POO) : Este paradigma, es un tipo de programaci\u00f3n imperativa, que mediante algunas t\u00e9cnicas (por ejemplo la herencia), resuelve algunas falencias que exist\u00edan en la programaci\u00f3n procedural (por ejemplo la reutilizaci\u00f3n de c\u00f3digo), utilizando objetos, cada uno de ellos, compuestos por un estado (datos) y un comportamiento. Programaci\u00f3n declarativa : Es un paradigma de la programaci\u00f3n, en la que los programas se describen en t\u00e9rminos de proposiciones y afirmaciones, que son declaradas , en donde los pasos para resolverlo, no impera. En este tipo de programaci\u00f3n, nos encontraremos mucha recursividad. Programaci\u00f3n Funcional : Es un paradigma que pertenece a la programaci\u00f3n declarativa, basado en el trabajo de Alonzo Church y Stephen Kleene en la d\u00e9cada de 1930, llamado: El C\u00e1lculo Lambda; este paradigma se compone de funciones que deben cumplir ciertas reglas (por ejemplo, que sean funciones puras). en donde encontraremos formas recursivas de por ejemplo trabajar con arreglos como lo son: map , reduce o filter . La principal diferencia con la programaci\u00f3n orientada a objetos, es que la programaci\u00f3n funcional, no posee estados. Cliente : El ente que paga por el producto. Usuario : Es quien usa el producto. Stakeholder : Es quien sostiene la estaca, todo aqu\u00e9l se se ve afectado por el producto, positiva o negativamente. Framework : Un marco de trabajo, o framework, es una estructura real o conceptual destinada a servir de soporte o gu\u00eda para la construcci\u00f3n de algo que expande la estructura en algo \u00fatil. Para nuestro caso, es mejor que lo veamos como un software pre construido, al que le podemos ir adicionando piezas seg\u00fan sus reglas, con la finalidad obtener un producto personalizado a nuestras necesidades. Patr\u00f3n : Hechos o cosas recurrentes. Estos se repiten con previsibilidad, por lo tanto, pueden funcionar como modelo para producir determinada cosa a partir de ellos. Patr\u00f3n de dise\u00f1o de modelo-vista-controlador (MVC) : Especifica que una aplicaci\u00f3n consta de tres capas: La primera es el modelo de datos, que es la capa con la responsabilidad de la gesti\u00f3n de los datos, luego tenemos la capa de presentaci\u00f3n, es lo que el usuario ve, es decir, la vista. La forma en que la informaci\u00f3n sea presentada al usuario, son responsabilidad de esta capa, por \u00faltimo, tenemos la capa del controlador, que es la capa encargada de orquestar o controlar, la interacci\u00f3n de las dos capas anteriormente mencionadas. \u00bfQu\u00e9 es UML? UML (Unified Modeling language), es un lenguaje de modelado unificado, que surge a finales de la d\u00e9cada de los 80 y principios de los 90. Entre los a\u00f1os 94 y 96, Grady y Jim e Ivar, conocidos como; \"los tres amigos\", crearon finalmente UML. Resultado de un trabajo iterativo y gradual, que pone a nuestra disposici\u00f3n, una norma construida sobre muchas ideas y contribuciones realizadas (unificadas), por numerosos individuos y compa\u00f1\u00edas de la comunidad de la orientaci\u00f3n a objetos. UML es un lenguaje y no una metodolog\u00eda , esto suele causar confusiones. Las metodolog\u00edas poseen un lenguaje y un proceso para modelar. En este caso; el lenguaje de modelado es la notaci\u00f3n (gr\u00e1fica), de la que se valen las metodolog\u00edas para expresar los dise\u00f1os. Breve historia. En el a\u00f1o 1980, el paradigma de la orientaci\u00f3n a objetos; ya no era parte solamente del contexto cient\u00edfico, en vez de ello, se encontraba ya en uso \"cotidiano\" en lenguajes que comenzaron a ser ampliamente utilizados como Smalltalk , dando paso a la creaci\u00f3n de nuevos lenguajes basados en en la POO ., como es el caso de C++ . Antes de que todo esto ocurriera, ya exist\u00edan diferentes tipos de metodolog\u00edas para representar el dise\u00f1o de un software utilizando la programaci\u00f3n procedural ; pero ahora hab\u00eda que lograr el mismo \u00e9xito en la POO. Entre los a\u00f1os 90 y el 98, muchas fueron las organizaciones que intentaron llegar a un est\u00e1ndar unificado; pero finalmente \"los tres amigos\", y, su versi\u00f3n 1.1 de UML fueron los ganadores. Tal fue su \u00e9xito, que hasta el d\u00eda de hoy seguimos usando UML como el lenguaje, para representar el dise\u00f1o de artefactos de nuestras aplicaciones. \u00bfQu\u00e9 tan rigurosos debemos ser, a la hora de implementar este lenguaje? El prop\u00f3sito de UML es ser una herramienta, y, como tal, se debe tener en cuenta que su estricta utilizaci\u00f3n, ir\u00e1 directamente relacionada con el contexto en el que se est\u00e9 trabajando, por ejemplo, si estamos trabajando en una herramienta, que a partir de los modelos que se creen con UML, se genere c\u00f3digo de forma automatizada. Es en este caso, donde usaremos UML de forma rigurosa, para que el c\u00f3digo generado sea el que se necesita. En el caso que se desee utilizar UML en el contexto de una reuni\u00f3n en la que se desee entender un problema y donde los modelos dise\u00f1ados no sean documentados formalmente (por ejemplo en una pizarra en una reuni\u00f3n con el cliente), podemos entonces usar UML con mayor libertad, sin dar tanta importancia a los detalles, sino que basta con que expliquen el problema de una forma global. En este tipo de casos debemos usar lo m\u00ednimo que nos aporte una mejor interpretaci\u00f3n del problema que se desea resolver. Existen ocasiones en que la notaci\u00f3n oficial puede llegar a estorbar, en estos casos no hay que dudar en adaptar el lenguaje a las necesidades personales. Quiz\u00e1s puede ser mal visto el que no estemos usando UML con todas sus sutilezas; pero en este caso ganamos flexibilidad y mientras la comunicaci\u00f3n no se vea afectada, no existe mayor problema en alterar un poco este lenguaje. Hay que tener cuidado al momento de adaptarlo, no nos podemos exceder, ya que el diferir mucho la estructura oficial, puede resultar en que no se comprenda lo que se desee expresar. \u00bfQu\u00e9 debemos preguntarnos antes de usar UML? Ya se ha mencionado que UML lo usamos como una herramienta, y para que lo sea, tenemos que asegurarnos, que la utilizaci\u00f3n de este lenguaje sea \u00fatil . Despu\u00e9s de todo, los diagramas que realizamos pueden ser visualmente atractivos; pero ning\u00fan cliente va a agradecer la belleza de los dise\u00f1os que hemos generados con UML; lo que los clientes, usuarios, stakeholders, etc. quieren son aplicaciones que funcionan. Es por todo esto, que al momento de utilizar UML, debemos hacernos la siguiente pregunta: \u00bfCu\u00e1l ser\u00e1 el beneficio de utilizarlo? y \u00bfC\u00f3mo su uso ayudar\u00e1 al momento de implementar el c\u00f3digo?. Si estas preguntas no tienen una respuesta clara. Entonces, quiz\u00e1s el uso de modelos construidos con UML, no generan un real aporte, que justifiquen su utilizaci\u00f3n. UML y los paradigmas de programaci\u00f3n. El reconocido empresario de las tecnolog\u00edas de la informaci\u00f3n Tom Hadfield , quien a la edad de doce a\u00f1os, cre\u00f3 junto a su padre socckernet (1994) , sitio que fue vendido a ESPN en 40 millones de d\u00f3lares dice: los lenguajes de objetos, permiten ventajas pero no las proporcionan. Para aprovechar estas ventajas hay que realizar el infame cambio de paradigma. (\u00a1S\u00f3lo aseg\u00farese de estar sentado al momento de hacerlo!) La mayor\u00eda de las personas que pod\u00edan reconocer la programaci\u00f3n en esos a\u00f1os e incluso en ahora, la asocia al paradigma de la programaci\u00f3n imperativa. Antes de que el mundo comenzara a utilizar la POO de forma natural, se utilizaba la programaci\u00f3n procedural, y esto era lo usual, lo que sab\u00edamos, por tanto, un cambio en el paradigma supon\u00eda un esfuerzo que queda reflejado en la frase de Hadfield. Entonces estamos ante una herramienta que nos permite modelar, y por ejemplo, por medio de un framework llevar\u00edamos r\u00e1pidamente a c\u00f3digo los diagramas que hemos dise\u00f1ado, si est\u00e1n correctamente dise\u00f1ados por supuesto. Todo esto gracias a que UML fue concebido para la POO. Entonces, \u00bfen qu\u00e9 situaci\u00f3n nos encontramos ahora?. Se podr\u00eda afirmar que un \"nuevo\" paradigma emerge, el paradigma de la programaci\u00f3n declarativa, todo esto debido a que lenguajes como javascript que toma fuerza en la cantidad de aplicaciones que existentes o que se est\u00e9n desarrollando; pero hay que mencionar que este lenguaje, es un lenguaje funcional (hija del paradigma declarativo); pero adem\u00e1s es un lenguaje imperativo. Entonces nos encontramos ante una mezcla de lo que es programaci\u00f3n funcional y programaci\u00f3n orientada a objetos. Quiz\u00e1s debamos comenzar a comprender que esta mezcla de paradigmas puede coexistir y debemos acostumbrarnos a ello, verlo como una nueva forma de construir, y, no verlo como un dolor de cabeza, hasta que nos acostumbremos a su uso. UML nos seguir\u00e1 sirviendo para representar gr\u00e1ficamente problemas; pero quiz\u00e1s el enfoque cambie un poco, hacia la utilizaci\u00f3n de nuevas herramientas que mezcle lo funcional con lo orientado a objetos. Ver\u00e1n que en librer\u00edas como React js ya se est\u00e1 usando esta mezcla de paradigmas y que cada nueva versi\u00f3n de Java, incluye muchas herramientas que permiten usar la programaci\u00f3n funcional.","title":"Lectura"},{"location":"uml/lectura/#lectura","text":"","title":"Lectura"},{"location":"uml/lectura/#capitulo-1-introduccion","text":"","title":"Cap\u00edtulo 1: Introducci\u00f3n."},{"location":"uml/lectura/#competencias-esperadas","text":"Conocer el lenguaje de modelado unificado (UML). Conocer los distintos tipos de diagramas.","title":"Competencias esperadas:"},{"location":"uml/lectura/#glosario-del-capitulo","text":"Notaci\u00f3n : Es la acci\u00f3n y efecto de notar, hace referencia al sistema de signos convencionales que se adopta, para expresar alg\u00fan concepto. Metodolog\u00eda : Grupo de mecanismos o procedimientos racionales, empleados para el logro de un objetivo. Paradigma : Teor\u00eda o conjunto de teor\u00edas, cuyo n\u00facleo central se acepta sin cuestionar y que suministra la base y modelo para resolver problemas y avanzar en el conocimiento Software : Conjunto de programas, instrucciones y reglas inform\u00e1ticas que permiten ejecutar distintas tareas en una computadora. Programaci\u00f3n Imperativa : En este paradigma de la programaci\u00f3n, que, como su nombre lo indica, imperan las instrucciones, condiciones o pasos indicamos exactamente, lo que el programa debe hacer. T\u00edpicamente nos encontraremos con estructuras c\u00edclicas tales como: while, for. Tambi\u00e9n condicionales if o switch. Lo que no quiere decir que si un programa posee estas instrucciones es puramente imperativo. Podemos reconocer este tipo de programaci\u00f3n cuando leemos el c\u00f3digo y su traza es una interpretaci\u00f3n de lectura secuencial de lo que est\u00e1 escrito. Programaci\u00f3n procedural : Se trata de un estilo de programaci\u00f3n; basado en estructurar el c\u00f3digo de un programa en componentes, que reciben el nombre de procedimientos, subrutinas o funciones. Programaci\u00f3n Orientada a Objetos (POO) : Este paradigma, es un tipo de programaci\u00f3n imperativa, que mediante algunas t\u00e9cnicas (por ejemplo la herencia), resuelve algunas falencias que exist\u00edan en la programaci\u00f3n procedural (por ejemplo la reutilizaci\u00f3n de c\u00f3digo), utilizando objetos, cada uno de ellos, compuestos por un estado (datos) y un comportamiento. Programaci\u00f3n declarativa : Es un paradigma de la programaci\u00f3n, en la que los programas se describen en t\u00e9rminos de proposiciones y afirmaciones, que son declaradas , en donde los pasos para resolverlo, no impera. En este tipo de programaci\u00f3n, nos encontraremos mucha recursividad. Programaci\u00f3n Funcional : Es un paradigma que pertenece a la programaci\u00f3n declarativa, basado en el trabajo de Alonzo Church y Stephen Kleene en la d\u00e9cada de 1930, llamado: El C\u00e1lculo Lambda; este paradigma se compone de funciones que deben cumplir ciertas reglas (por ejemplo, que sean funciones puras). en donde encontraremos formas recursivas de por ejemplo trabajar con arreglos como lo son: map , reduce o filter . La principal diferencia con la programaci\u00f3n orientada a objetos, es que la programaci\u00f3n funcional, no posee estados. Cliente : El ente que paga por el producto. Usuario : Es quien usa el producto. Stakeholder : Es quien sostiene la estaca, todo aqu\u00e9l se se ve afectado por el producto, positiva o negativamente. Framework : Un marco de trabajo, o framework, es una estructura real o conceptual destinada a servir de soporte o gu\u00eda para la construcci\u00f3n de algo que expande la estructura en algo \u00fatil. Para nuestro caso, es mejor que lo veamos como un software pre construido, al que le podemos ir adicionando piezas seg\u00fan sus reglas, con la finalidad obtener un producto personalizado a nuestras necesidades. Patr\u00f3n : Hechos o cosas recurrentes. Estos se repiten con previsibilidad, por lo tanto, pueden funcionar como modelo para producir determinada cosa a partir de ellos. Patr\u00f3n de dise\u00f1o de modelo-vista-controlador (MVC) : Especifica que una aplicaci\u00f3n consta de tres capas: La primera es el modelo de datos, que es la capa con la responsabilidad de la gesti\u00f3n de los datos, luego tenemos la capa de presentaci\u00f3n, es lo que el usuario ve, es decir, la vista. La forma en que la informaci\u00f3n sea presentada al usuario, son responsabilidad de esta capa, por \u00faltimo, tenemos la capa del controlador, que es la capa encargada de orquestar o controlar, la interacci\u00f3n de las dos capas anteriormente mencionadas.","title":"Glosario del cap\u00edtulo:"},{"location":"uml/lectura/#que-es-uml","text":"UML (Unified Modeling language), es un lenguaje de modelado unificado, que surge a finales de la d\u00e9cada de los 80 y principios de los 90. Entre los a\u00f1os 94 y 96, Grady y Jim e Ivar, conocidos como; \"los tres amigos\", crearon finalmente UML. Resultado de un trabajo iterativo y gradual, que pone a nuestra disposici\u00f3n, una norma construida sobre muchas ideas y contribuciones realizadas (unificadas), por numerosos individuos y compa\u00f1\u00edas de la comunidad de la orientaci\u00f3n a objetos. UML es un lenguaje y no una metodolog\u00eda , esto suele causar confusiones. Las metodolog\u00edas poseen un lenguaje y un proceso para modelar. En este caso; el lenguaje de modelado es la notaci\u00f3n (gr\u00e1fica), de la que se valen las metodolog\u00edas para expresar los dise\u00f1os.","title":"\u00bfQu\u00e9 es UML?"},{"location":"uml/lectura/#breve-historia","text":"En el a\u00f1o 1980, el paradigma de la orientaci\u00f3n a objetos; ya no era parte solamente del contexto cient\u00edfico, en vez de ello, se encontraba ya en uso \"cotidiano\" en lenguajes que comenzaron a ser ampliamente utilizados como Smalltalk , dando paso a la creaci\u00f3n de nuevos lenguajes basados en en la POO ., como es el caso de C++ . Antes de que todo esto ocurriera, ya exist\u00edan diferentes tipos de metodolog\u00edas para representar el dise\u00f1o de un software utilizando la programaci\u00f3n procedural ; pero ahora hab\u00eda que lograr el mismo \u00e9xito en la POO. Entre los a\u00f1os 90 y el 98, muchas fueron las organizaciones que intentaron llegar a un est\u00e1ndar unificado; pero finalmente \"los tres amigos\", y, su versi\u00f3n 1.1 de UML fueron los ganadores. Tal fue su \u00e9xito, que hasta el d\u00eda de hoy seguimos usando UML como el lenguaje, para representar el dise\u00f1o de artefactos de nuestras aplicaciones.","title":"Breve historia."},{"location":"uml/lectura/#que-tan-rigurosos-debemos-ser-a-la-hora-de-implementar-este-lenguaje","text":"El prop\u00f3sito de UML es ser una herramienta, y, como tal, se debe tener en cuenta que su estricta utilizaci\u00f3n, ir\u00e1 directamente relacionada con el contexto en el que se est\u00e9 trabajando, por ejemplo, si estamos trabajando en una herramienta, que a partir de los modelos que se creen con UML, se genere c\u00f3digo de forma automatizada. Es en este caso, donde usaremos UML de forma rigurosa, para que el c\u00f3digo generado sea el que se necesita. En el caso que se desee utilizar UML en el contexto de una reuni\u00f3n en la que se desee entender un problema y donde los modelos dise\u00f1ados no sean documentados formalmente (por ejemplo en una pizarra en una reuni\u00f3n con el cliente), podemos entonces usar UML con mayor libertad, sin dar tanta importancia a los detalles, sino que basta con que expliquen el problema de una forma global. En este tipo de casos debemos usar lo m\u00ednimo que nos aporte una mejor interpretaci\u00f3n del problema que se desea resolver. Existen ocasiones en que la notaci\u00f3n oficial puede llegar a estorbar, en estos casos no hay que dudar en adaptar el lenguaje a las necesidades personales. Quiz\u00e1s puede ser mal visto el que no estemos usando UML con todas sus sutilezas; pero en este caso ganamos flexibilidad y mientras la comunicaci\u00f3n no se vea afectada, no existe mayor problema en alterar un poco este lenguaje. Hay que tener cuidado al momento de adaptarlo, no nos podemos exceder, ya que el diferir mucho la estructura oficial, puede resultar en que no se comprenda lo que se desee expresar.","title":"\u00bfQu\u00e9 tan rigurosos debemos ser, a la hora de implementar este lenguaje?"},{"location":"uml/lectura/#que-debemos-preguntarnos-antes-de-usar-uml","text":"Ya se ha mencionado que UML lo usamos como una herramienta, y para que lo sea, tenemos que asegurarnos, que la utilizaci\u00f3n de este lenguaje sea \u00fatil . Despu\u00e9s de todo, los diagramas que realizamos pueden ser visualmente atractivos; pero ning\u00fan cliente va a agradecer la belleza de los dise\u00f1os que hemos generados con UML; lo que los clientes, usuarios, stakeholders, etc. quieren son aplicaciones que funcionan. Es por todo esto, que al momento de utilizar UML, debemos hacernos la siguiente pregunta: \u00bfCu\u00e1l ser\u00e1 el beneficio de utilizarlo? y \u00bfC\u00f3mo su uso ayudar\u00e1 al momento de implementar el c\u00f3digo?. Si estas preguntas no tienen una respuesta clara. Entonces, quiz\u00e1s el uso de modelos construidos con UML, no generan un real aporte, que justifiquen su utilizaci\u00f3n.","title":"\u00bfQu\u00e9 debemos preguntarnos antes de usar UML?"},{"location":"uml/lectura/#uml-y-los-paradigmas-de-programacion","text":"El reconocido empresario de las tecnolog\u00edas de la informaci\u00f3n Tom Hadfield , quien a la edad de doce a\u00f1os, cre\u00f3 junto a su padre socckernet (1994) , sitio que fue vendido a ESPN en 40 millones de d\u00f3lares dice: los lenguajes de objetos, permiten ventajas pero no las proporcionan. Para aprovechar estas ventajas hay que realizar el infame cambio de paradigma. (\u00a1S\u00f3lo aseg\u00farese de estar sentado al momento de hacerlo!) La mayor\u00eda de las personas que pod\u00edan reconocer la programaci\u00f3n en esos a\u00f1os e incluso en ahora, la asocia al paradigma de la programaci\u00f3n imperativa. Antes de que el mundo comenzara a utilizar la POO de forma natural, se utilizaba la programaci\u00f3n procedural, y esto era lo usual, lo que sab\u00edamos, por tanto, un cambio en el paradigma supon\u00eda un esfuerzo que queda reflejado en la frase de Hadfield. Entonces estamos ante una herramienta que nos permite modelar, y por ejemplo, por medio de un framework llevar\u00edamos r\u00e1pidamente a c\u00f3digo los diagramas que hemos dise\u00f1ado, si est\u00e1n correctamente dise\u00f1ados por supuesto. Todo esto gracias a que UML fue concebido para la POO. Entonces, \u00bfen qu\u00e9 situaci\u00f3n nos encontramos ahora?. Se podr\u00eda afirmar que un \"nuevo\" paradigma emerge, el paradigma de la programaci\u00f3n declarativa, todo esto debido a que lenguajes como javascript que toma fuerza en la cantidad de aplicaciones que existentes o que se est\u00e9n desarrollando; pero hay que mencionar que este lenguaje, es un lenguaje funcional (hija del paradigma declarativo); pero adem\u00e1s es un lenguaje imperativo. Entonces nos encontramos ante una mezcla de lo que es programaci\u00f3n funcional y programaci\u00f3n orientada a objetos. Quiz\u00e1s debamos comenzar a comprender que esta mezcla de paradigmas puede coexistir y debemos acostumbrarnos a ello, verlo como una nueva forma de construir, y, no verlo como un dolor de cabeza, hasta que nos acostumbremos a su uso. UML nos seguir\u00e1 sirviendo para representar gr\u00e1ficamente problemas; pero quiz\u00e1s el enfoque cambie un poco, hacia la utilizaci\u00f3n de nuevas herramientas que mezcle lo funcional con lo orientado a objetos. Ver\u00e1n que en librer\u00edas como React js ya se est\u00e1 usando esta mezcla de paradigmas y que cada nueva versi\u00f3n de Java, incluye muchas herramientas que permiten usar la programaci\u00f3n funcional.","title":"UML y los paradigmas de programaci\u00f3n."}]}