{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"hola mundo","title":"hola mundo"},{"location":"#hola-mundo","text":"","title":"hola mundo"},{"location":"uml/lectura/","text":"Nombre de la unidad UML Descripci\u00f3n unidad En el cap\u00edtulo de UML se conocer\u00e1 el lenguaje de modelamiento unificado (UML), con el cual se aprender\u00e1 a crear casos de usos, diagramas de secuencias y diagramas de clases, para agilizar la creaci\u00f3n de piezas de software. Requerimientos Conocimiento previo del paradigma de programaci\u00f3n orientado a objetos. Tener una herramienta de modelado como StarUml . Referencias UML distilled - Martin Fowler. El Lenguaje Unificado de Modelado - J. Rumbaugh, I. Jacobson, G. Booch. https://www.smartdraw.com/uml-diagram/ https://ingenieriadesoftware.es/opiniones-lenguaje-uml-20-anos/ https://www.uml.org Glosario Aplicaci\u00f3n : Es un tipo de software que permite al usuario realizar uno o m\u00e1s tipos de trabajo. Notaci\u00f3n : Es la acci\u00f3n y efecto de notar, hace referencia al sistema de signos convencionales que se adopta, para expresar alg\u00fan concepto. Metodolog\u00eda : Grupo de mecanismos o procedimientos racionales, empleados para el logro de un objetivo. Paradigma : Teor\u00eda o conjunto de teor\u00edas, cuyo n\u00facleo central se acepta sin cuestionar y que suministra la base y modelo para resolver problemas y avanzar en el conocimiento. Software : Conjunto de programas, instrucciones y reglas inform\u00e1ticas que permiten ejecutar distintas tareas en una computadora. Programaci\u00f3n Imperativa : En este paradigma de la programaci\u00f3n, que, como su nombre lo indica, imperan las instrucciones, condiciones o pasos indicamos exactamente, lo que el programa debe hacer. T\u00edpicamente nos encontraremos con estructuras c\u00edclicas tales como: while, for. Tambi\u00e9n condicionales if o switch. Lo que no quiere decir que si un programa posee estas instrucciones es puramente imperativo. Podemos reconocer este tipo de programaci\u00f3n cuando leemos el c\u00f3digo y su traza es una interpretaci\u00f3n de lectura secuencial de lo que est\u00e1 escrito. Programaci\u00f3n procedural : Se trata de un estilo de programaci\u00f3n; basado en estructurar el c\u00f3digo de un programa en componentes, que reciben el nombre de procedimientos, subrutinas o funciones. Programaci\u00f3n Orientada a Objetos (POO) : Este paradigma, es un tipo de programaci\u00f3n imperativa, que mediante algunas t\u00e9cnicas (por ejemplo la herencia), resuelve algunas falencias que exist\u00edan en la programaci\u00f3n procedural (por ejemplo la reutilizaci\u00f3n de c\u00f3digo), utilizando objetos, cada uno de ellos, compuestos por un estado (datos) y un comportamiento. Programaci\u00f3n declarativa : Es un paradigma de la programaci\u00f3n, en la que los programas se describen en t\u00e9rminos de proposiciones y afirmaciones, que son declaradas , en donde los pasos para resolverlo, no impera. En este tipo de programaci\u00f3n, nos encontraremos mucha recursividad. Programaci\u00f3n Funcional : Es un paradigma que pertenece a la programaci\u00f3n declarativa, basado en el trabajo de Alonzo Church y Stephen Kleene en la d\u00e9cada de 1930, llamado: El C\u00e1lculo Lambda; este paradigma se compone de funciones que deben cumplir ciertas reglas (por ejemplo, que sean funciones puras). en donde encontraremos formas recursivas de por ejemplo trabajar con arreglos como lo son: map , reduce o filter . La principal diferencia con la programaci\u00f3n orientada a objetos, es que la programaci\u00f3n funcional, no posee estados. Cliente : El ente que paga por el producto. Usuario : Es quien usa el producto. Stakeholder : Es quien sostiene la estaca, todo aqu\u00e9l se se ve afectado por el producto y/o proyecto. Framework : Un marco de trabajo, o framework, es una estructura real o conceptual destinada a servir de soporte o gu\u00eda para la construcci\u00f3n de algo que expande la estructura en algo \u00fatil. Para nuestro caso, es mejor que lo veamos como un software pre construido, al que le podemos ir adicionando piezas seg\u00fan sus reglas, con la finalidad obtener un producto personalizado a nuestras necesidades. Patr\u00f3n : Hechos o cosas recurrentes. Estos se repiten con previsibilidad, por lo tanto, pueden funcionar como modelo para producir determinada cosa a partir de ellos. Patr\u00f3n de dise\u00f1o de modelo-vista-controlador (MVC) : Especifica que una aplicaci\u00f3n consta de tres capas: La primera es el modelo de datos, que es la capa con la responsabilidad de la gesti\u00f3n de los datos, luego tenemos la capa de presentaci\u00f3n, es lo que el usuario ve, es decir, la vista. La forma en que la informaci\u00f3n sea presentada al usuario, son responsabilidad de esta capa, por \u00faltimo, tenemos la capa del controlador, que es la capa encargada de orquestar o controlar, la interacci\u00f3n de las dos capas anteriormente mencionadas. Agilidad : Se refiere a la flexibilidad que posee un proyecto, es decir, que pueda cambiar y que esto no produzca un alto impacto en el esfuerzo. Cap\u00edtulo 1: Introducci\u00f3n a UML. Competencias esperadas. Conocer el lenguaje de modelado unificado (UML). Conocer los distintos tipos de diagramas. Reconocer el paradigma de la programaci\u00f3n en el que est\u00e1 basado UML. Entender el concepto del proceso de creaci\u00f3n de software. \u00bfQu\u00e9 es un modelo? Un modelo, es una representaci\u00f3n de algo, en cierto medio (Papel, pantallas, maquetas, etc.), que capta los aspectos principales, ignorando los menos importantes o que no aporten informaci\u00f3n relevante. Un modelo en un sistema de software est\u00e1 expresado mediante UML. \u00bfQu\u00e9 es UML? UML (Unified Modeling language), es un lenguaje de modelado unificado, que surge a finales de la d\u00e9cada de los 80 y principios de los 90. Entre los a\u00f1os 94 y 96, Grady y Jim e Ivar, conocidos como; \"los tres amigos\", crearon finalmente UML. Resultado de un trabajo iterativo y gradual, que pone a nuestra disposici\u00f3n, una norma construida sobre muchas ideas y contribuciones realizadas (unificadas), por numerosos individuos y compa\u00f1\u00edas de la comunidad de la orientaci\u00f3n a objetos. UML es un lenguaje y no una metodolog\u00eda , esto suele causar confusiones. Las metodolog\u00edas poseen un lenguaje y un proceso para modelar. En este caso; el lenguaje de modelado es la notaci\u00f3n (gr\u00e1fica), de la que se valen las metodolog\u00edas para expresar los dise\u00f1os. Breve historia. En el a\u00f1o 1980, el paradigma de la orientaci\u00f3n a objetos; ya no era parte solamente del contexto cient\u00edfico, en vez de ello, se encontraba ya en uso \"cotidiano\" en lenguajes que comenzaron a ser ampliamente utilizados como Smalltalk , dando paso a la creaci\u00f3n de nuevos lenguajes basados en en la POO ., como es el caso de C++ . Antes de que todo esto ocurriera, ya exist\u00edan diferentes tipos de metodolog\u00edas para representar el dise\u00f1o de un software utilizando la programaci\u00f3n procedural ; pero ahora hab\u00eda que lograr el mismo \u00e9xito en la POO. Entre los a\u00f1os 90 y el 98, muchas fueron las organizaciones que intentaron llegar a un est\u00e1ndar unificado; pero finalmente \"los tres amigos\", y, su versi\u00f3n 1.1 de UML fueron los ganadores. Tal fue su \u00e9xito, que hasta el d\u00eda de hoy seguimos usando UML como el lenguaje, para representar el dise\u00f1o de artefactos de nuestras aplicaciones. \u00bfQu\u00e9 tan rigurosos debemos ser, a la hora de implementar este lenguaje? El prop\u00f3sito de UML es ser una herramienta, y, como tal, se debe tener en cuenta que su estricta utilizaci\u00f3n, ir\u00e1 directamente relacionada con el contexto en el que se est\u00e9 trabajando, por ejemplo, si estamos trabajando en una herramienta, que a partir de los modelos que se creen con UML, se genere c\u00f3digo de forma automatizada. Es en este caso, donde usaremos UML de forma rigurosa, para que el c\u00f3digo generado sea el que se necesita. En el caso que se desee utilizar UML en el contexto de una reuni\u00f3n en la que se desee entender un problema y donde los modelos dise\u00f1ados no sean documentados formalmente (por ejemplo en una pizarra en una reuni\u00f3n con el cliente), podemos entonces usar UML con mayor libertad, sin dar tanta importancia a los detalles, sino que basta con que expliquen el problema de una forma global. En este tipo de casos debemos usar lo m\u00ednimo que nos aporte una mejor interpretaci\u00f3n del problema que se desea resolver. Existen ocasiones en que la notaci\u00f3n oficial puede llegar a estorbar, en estos casos no hay que dudar en adaptar el lenguaje a las necesidades personales. Quiz\u00e1s puede ser mal visto el que no estemos usando UML con todas sus sutilezas; pero en este caso ganamos flexibilidad y mientras la comunicaci\u00f3n no se vea afectada, no existe mayor problema en alterar un poco este lenguaje. Hay que tener cuidado al momento de adaptarlo, no nos podemos exceder, ya que el diferir mucho la estructura oficial, puede resultar en que no se comprenda lo que se desee expresar. \u00bfQu\u00e9 debemos preguntarnos antes de usar UML? Ya se ha mencionado que UML lo usamos como una herramienta, y para que lo sea, tenemos que asegurarnos, que la utilizaci\u00f3n de este lenguaje sea \u00fatil . Despu\u00e9s de todo, los diagramas que realizamos pueden ser visualmente atractivos; pero ning\u00fan cliente va a agradecer la belleza de los dise\u00f1os que hemos generados con UML; lo que los clientes, usuarios, stakeholders, etc. quieren son aplicaciones que funcionan. Es por todo esto, que al momento de utilizar UML, debemos hacernos la siguiente pregunta: \u00bfCu\u00e1l ser\u00e1 el beneficio de utilizarlo? y \u00bfC\u00f3mo su uso ayudar\u00e1 al momento de implementar el c\u00f3digo?. Si estas preguntas no tienen una respuesta clara. Entonces, quiz\u00e1s el uso de modelos construidos con UML, no generan un real aporte, que justifiquen su utilizaci\u00f3n. UML y los paradigmas de programaci\u00f3n. El reconocido empresario de las tecnolog\u00edas de la informaci\u00f3n Tom Hadfield , quien a la edad de doce a\u00f1os, cre\u00f3 junto a su padre socckernet (1994) , sitio que fue vendido a ESPN en 40 millones de d\u00f3lares dice: los lenguajes de objetos, permiten ventajas pero no las proporcionan. Para aprovechar estas ventajas hay que realizar el infame cambio de paradigma. (\u00a1S\u00f3lo aseg\u00farese de estar sentado al momento de hacerlo!) La mayor\u00eda de las personas que pod\u00edan reconocer la programaci\u00f3n en esos a\u00f1os e incluso en ahora, la asocia al paradigma de la programaci\u00f3n imperativa. Antes de que el mundo comenzara a utilizar la POO de forma natural, se utilizaba la programaci\u00f3n procedural, y esto era lo usual, lo que sab\u00edamos, por tanto, un cambio en el paradigma supon\u00eda un esfuerzo que queda reflejado en la frase de Hadfield. Entonces estamos ante una herramienta que nos permite modelar, y por ejemplo, por medio de un framework llevar\u00edamos r\u00e1pidamente a c\u00f3digo los diagramas que hemos dise\u00f1ado, si est\u00e1n correctamente dise\u00f1ados por supuesto. Todo esto gracias a que UML fue concebido para la POO. Entonces, \u00bfen qu\u00e9 situaci\u00f3n nos encontramos ahora?. Se podr\u00eda afirmar que un \"nuevo\" paradigma emerge, el paradigma de la programaci\u00f3n declarativa, todo esto debido a que lenguajes como javascript , que toma fuerza en la cantidad de aplicaciones que existentes o que se est\u00e9n desarrollando; pero hay que mencionar que este lenguaje, es un lenguaje funcional (hija del paradigma declarativo), y, adem\u00e1s es un lenguaje imperativo. Entonces nos encontramos ante una mezcla de lo que es programaci\u00f3n funcional y programaci\u00f3n orientada a objetos. Quiz\u00e1s debamos comenzar a comprender que esta mezcla de paradigmas puede coexistir y debemos acostumbrarnos a ello, verlo como una nueva forma de construir, y, no verlo como un dolor de cabeza, hasta que nos acostumbremos a su uso. UML nos seguir\u00e1 sirviendo para representar gr\u00e1ficamente problemas; pero quiz\u00e1s el enfoque cambie un poco, hacia la utilizaci\u00f3n de nuevas herramientas que mezcle lo funcional con lo orientado a objetos. Ver\u00e1n que en librer\u00edas como _React js_ ya utiliza esta mezcla de paradigmas y que cada nueva versi\u00f3n de Java, incluye muchas herramientas que permiten usar la programaci\u00f3n funcional. Como sea que termine esta hist\u00f3ria, UML a\u00fan nos entrega una interfaz entre lo que es abstracto y lo que podr\u00edamos llamar tangible. El proceso de desarrollo de software. UML, es un lenguaje para modelar, por eso no asume la noci\u00f3n de un proceso; pero para poder realizar un buen desarrollo, hay que analizar el propio proceso de desarrollar aplicaciones. Una visi\u00f3n del desarrollo en su nivel m\u00e1s alto ser\u00eda como la que muestra la figura 1.1. Figura 1.1: Proceso de desarrollo de software. Durante la concepci\u00f3n, se establece la raz\u00f3n de ser del proyecto, adem\u00e1s del alcance del mismo. Es en esta etapa en donde se define si el proyecto se realiza o no. En la elaboraci\u00f3n, se detallan m\u00e1s profundamente los requerimientos, para as\u00ed llegar a confeccionar una arquitectura base. Los dise\u00f1os utilizados han de ser de alto nivel, es decir, sin gran nivel de detalle, destacando solamente lo principal. Dependiendo del nivel de agilidad del proyecto, esta etapa puede ser desde una reuni\u00f3n de un par de horas, hasta una entrega de documentos formales, con iteraciones. Al finalizar esta etapa, las preguntas: \u00bfQu\u00e9 es lo que va a construir en realidad?, \u00bfC\u00f3mo lo va a construir?, \u00bfQu\u00e9 tecnolog\u00eda emplear\u00e1?, deben ser contestadas. En la construcci\u00f3n, como se indica en la figura 1.1, la iteraci\u00f3n es clave. No quiere decir que el las otras etapas no se pueda iterar; pero en esta etapa, cada iteraci\u00f3n es un mini proyecto. Terminando con una demostraci\u00f3n funcional al stakeholder. Con ello reducimos el riesgo, ya que si algo no ha salido como se quer\u00eda, solamente est\u00e1 en juego la iteraci\u00f3n y no el proyecto completo. La funcionalidad ser\u00e1 incremental y la construcci\u00f3n de c\u00f3digo ser\u00e1 iterativa. \u00bfCu\u00e1ndo se debe usar el desarrollo iterativo? El desarrollo iterativo \u00fanicamente se debe utilizar en aquellos proyectos que se quiere que tengan \u00e9xito. Todas las t\u00e9cnicas de UML son \u00fatiles durante esta etapa; pero hay que ser cuidadosos, de no excedernos, como dice la siguiente cita: Los memorandos cuidadosamente escritos y seleccionados, pueden sustituir con toda facilidad a la tradicional documentaci\u00f3n detallada del dise\u00f1o. Esta \u00faltima es sobresaliente en pocas ocasiones, excepto en algunos puntos aislados. Destaque estos puntos... y olv\u00eddese del resto.. \"Ward Cunningham (1996)\" Durante la transici\u00f3n, no se hacen desarrollos para a\u00f1adir funciones nuevas (a menos que sean peque\u00f1as y absolutamente indispensables). Ciertamente, s\u00ed hay desarrollo para depuraci\u00f3n. Un buen ejemplo de una fase de transici\u00f3n es el tiempo entre la liberaci\u00f3n beta y ]a liberaci\u00f3n definitiva del producto. Tipos de diagramas en UML. No existe una l\u00ednea que divida claramente UML; pero podemos reconocer los diferentes tipos de diagramas, para poder apreciar el aspecto del sistema que se intenta representar. Tipos Estructurales Diagrama de clases. Diagrama de paquetes. Diagrama de objetos. Diagrama de componentes. Diagrama de estructura compuesta. Diagrama de despliegue. Tipos comportamiento. Diagrama de actividad. Diagrama de secuencia. Diagrama de casos de uso. Diagrama de estado. Diagrama de comunicaci\u00f3n. Diagrama de interacci\u00f3n. Diagrama de sincronizaci\u00f3n. Los diagramas que est\u00e1n destacados, se detallar\u00e1n en los cap\u00edtulos posteriores. Esto no se debe a que los dem\u00e1s no sirvan o sean menos importantes, m\u00e1s bien, se trata de poder utilizar lo mejor de UML, para resolver la mayor\u00eda de los problemas de dise\u00f1o de software. \"De verdad, s\u00f3lo necesitas un 20% del UML, para modelar el 80% del dise\u00f1o que necesitar\u00e1s en un proyecto \u2013 \u00e1gil o no\". - Grady Booch. Cap\u00edtulo 2: Los casos de uso. 2.1 Competencias esperadas. Comprender el concepto de casos de uso. Construir caso de uso. Identificar los casos de uso, para una problem\u00e1tica y representarla con la notaci\u00f3n UML. 2.2 Introducci\u00f3n. Durante mucho tiempo, cuando era utilizado el paradigma procedural de forma popular, incluso cuando la POO comenzaba a ser muy conocida y utilizada. Los escenarios eran representados de forma muy r\u00fastica. las personas se auxiliaban de escenarios t\u00edpicos que les ayudaban a comprender los requerimientos. Muchas veces se constru\u00edan; pero no se documentaban, Ivar Jacobson, uno de los tres creadores de UML, elev\u00f3 la visibilidad del caso de uso (su nombre para un escenario) a tal punto, que lo convirti\u00f3 en un elemento primario de la planificaci\u00f3n y el desarrollo de proyectos de software. 2.3 Diagramas de casos de uso. En el a\u00f1o 1994, Jacobson no solo logr\u00f3 introducir los casos de uso como un concepto para ayudar en los primeros pasos del desarrollo de aplicaciones, adem\u00e1s, desarrollo una representaci\u00f3n gr\u00e1fica de este hecho y lo llam\u00f3 El Diagrama de Casos de Uso , y este diagrama ahora forma parte de UML. Una representaci\u00f3n de un diagrama de casos de uso ser\u00eda el siguiente: Figura 2.1: Diagrama de casos de uso b\u00e1sico. 2.3.1 Casos de uso (CU) Un caso de uso es, en esencia, una interacci\u00f3n t\u00edpica entre un usuario y un sistema de software . considere la aplicaci\u00f3n con la que se escriben estas l\u00edneas que usted lee. Dos casos de uso t\u00edpicos ser\u00edan \"poner una parte del texto en negritas\" y \"Borrar el texto seleccionado\". Por medio de estos ejemplos, se puede uno dar una idea de ciertas propiedades de los casos de uso. Figura 2.2: Notaci\u00f3n de un caso de uso. Capta alguna funci\u00f3n visible para el usuario. Puede ser peque\u00f1o o grande. Logra un objetivo discreto para el usuario. Usualmente, el caso de uso se extrae de las interacciones, que los potenciales usuarios del sistema tengan con la aplicaci\u00f3n que se desee construir. Cada una de estas, se debe abordar de forma discreta, darle un nombre y escribir una breve descripci\u00f3n. No hay que detallar tan profundamente esta interacci\u00f3n, todo esto dependiendo de la cantidad de ramificaciones, de las que est\u00e9 compuesto el caso de uso, se podr\u00e1 m\u00e1s adelante obtener mayores detalles que pueden resultar en nuevos casos de uso. Objetivos del usuario vs interacciones con el sistema: Cuando se est\u00e1n tomando los requerimientos, a veces es f\u00e1cil confundirse entre los objetivos que el usuario tiene y las interacciones que har\u00e1 con el sistema . Supongamos el desarrollo de un sistema de ventas. Surgir\u00e1n interacciones como: \"Ingresar un producto\", \"actualizar precio\". etc. Esto difiere de los objetivos que pueda tener el usuario como, \"mantener la informaci\u00f3n de los precios actualizada\", \"Garantizar que est\u00e9 disponible la informaci\u00f3n de los productos\". En ambos casos tenemos requerimientos del usuario, pero la granularidad es diferente, ya que las interacciones son m\u00e1s sencillas de implementar que los objetivos. Cuando estamos reuniendo los casos de uso del sistema, debemos mantener una granularidad m\u00e1s o menos similar, es decir, el nivel de detalle y complejidad de cada caso de uso, debe ser similar. Finalmente como lo definimos, mantendremos el foco de la captura de los casos de uso, centradas en las interacciones, sin perder de vista los objetivos, en el caso que s\u00f3lo tengamos los objetivos del usuario, debemos granular esta informaci\u00f3n, en interacciones necesarias para que se cumplan los objetivos. Como recomendaci\u00f3n, es bueno tener varios casos de uso por objetivo, al menos los objetivos principales, ya que en las iteraciones que vayamos haciendo, se recibe mucho mejor que el usuario vea como se van cumpliendo sus objetivos (aunque lo m\u00e1s probable es que estos objetivos vayan evolucionando a medida que el sistema avanza). 2.3.2 Actores Empleamos el t\u00e9rmino actor para llamar as\u00ed al usuario, cuando desempe\u00f1a ese papel con respecto al sistema. Los actores llevan a cabo casos de uso. Un mismo actor puede realizar muchos casos de uso; a la inversa, un caso de uso puede ser realizado por varios actores. No es necesario que los actores sean seres humanos , a pesar de que los actores est\u00e9n representados por figuras humanas. El actor puede ser tambi\u00e9n un sistema externo que necesite cierta informaci\u00f3n del sistema actual Figura 2.3: Notaci\u00f3n de un actor. 2.3.3 Relaciones UML define cuatro tipos de relaciones en los diagramas de casos de uso: Comunicaci\u00f3n Esta relaci\u00f3n es la que m\u00e1s veremos en los CU, como estereotipo se representa por < > ; pero generalmente este estereotipo no va escrito. Es una relaci\u00f3n de asociaci\u00f3n que nos muestra la interacci\u00f3n entre un actor y el caso de uso. Figura 2.4: Relaci\u00f3n de comunicaci\u00f3n de asociaci\u00f3n.","title":"Lectura"},{"location":"uml/lectura/#nombre-de-la-unidad","text":"UML","title":"Nombre de la unidad"},{"location":"uml/lectura/#descripcion-unidad","text":"En el cap\u00edtulo de UML se conocer\u00e1 el lenguaje de modelamiento unificado (UML), con el cual se aprender\u00e1 a crear casos de usos, diagramas de secuencias y diagramas de clases, para agilizar la creaci\u00f3n de piezas de software.","title":"Descripci\u00f3n unidad"},{"location":"uml/lectura/#requerimientos","text":"Conocimiento previo del paradigma de programaci\u00f3n orientado a objetos. Tener una herramienta de modelado como StarUml .","title":"Requerimientos"},{"location":"uml/lectura/#referencias","text":"UML distilled - Martin Fowler. El Lenguaje Unificado de Modelado - J. Rumbaugh, I. Jacobson, G. Booch. https://www.smartdraw.com/uml-diagram/ https://ingenieriadesoftware.es/opiniones-lenguaje-uml-20-anos/ https://www.uml.org","title":"Referencias"},{"location":"uml/lectura/#glosario","text":"Aplicaci\u00f3n : Es un tipo de software que permite al usuario realizar uno o m\u00e1s tipos de trabajo. Notaci\u00f3n : Es la acci\u00f3n y efecto de notar, hace referencia al sistema de signos convencionales que se adopta, para expresar alg\u00fan concepto. Metodolog\u00eda : Grupo de mecanismos o procedimientos racionales, empleados para el logro de un objetivo. Paradigma : Teor\u00eda o conjunto de teor\u00edas, cuyo n\u00facleo central se acepta sin cuestionar y que suministra la base y modelo para resolver problemas y avanzar en el conocimiento. Software : Conjunto de programas, instrucciones y reglas inform\u00e1ticas que permiten ejecutar distintas tareas en una computadora. Programaci\u00f3n Imperativa : En este paradigma de la programaci\u00f3n, que, como su nombre lo indica, imperan las instrucciones, condiciones o pasos indicamos exactamente, lo que el programa debe hacer. T\u00edpicamente nos encontraremos con estructuras c\u00edclicas tales como: while, for. Tambi\u00e9n condicionales if o switch. Lo que no quiere decir que si un programa posee estas instrucciones es puramente imperativo. Podemos reconocer este tipo de programaci\u00f3n cuando leemos el c\u00f3digo y su traza es una interpretaci\u00f3n de lectura secuencial de lo que est\u00e1 escrito. Programaci\u00f3n procedural : Se trata de un estilo de programaci\u00f3n; basado en estructurar el c\u00f3digo de un programa en componentes, que reciben el nombre de procedimientos, subrutinas o funciones. Programaci\u00f3n Orientada a Objetos (POO) : Este paradigma, es un tipo de programaci\u00f3n imperativa, que mediante algunas t\u00e9cnicas (por ejemplo la herencia), resuelve algunas falencias que exist\u00edan en la programaci\u00f3n procedural (por ejemplo la reutilizaci\u00f3n de c\u00f3digo), utilizando objetos, cada uno de ellos, compuestos por un estado (datos) y un comportamiento. Programaci\u00f3n declarativa : Es un paradigma de la programaci\u00f3n, en la que los programas se describen en t\u00e9rminos de proposiciones y afirmaciones, que son declaradas , en donde los pasos para resolverlo, no impera. En este tipo de programaci\u00f3n, nos encontraremos mucha recursividad. Programaci\u00f3n Funcional : Es un paradigma que pertenece a la programaci\u00f3n declarativa, basado en el trabajo de Alonzo Church y Stephen Kleene en la d\u00e9cada de 1930, llamado: El C\u00e1lculo Lambda; este paradigma se compone de funciones que deben cumplir ciertas reglas (por ejemplo, que sean funciones puras). en donde encontraremos formas recursivas de por ejemplo trabajar con arreglos como lo son: map , reduce o filter . La principal diferencia con la programaci\u00f3n orientada a objetos, es que la programaci\u00f3n funcional, no posee estados. Cliente : El ente que paga por el producto. Usuario : Es quien usa el producto. Stakeholder : Es quien sostiene la estaca, todo aqu\u00e9l se se ve afectado por el producto y/o proyecto. Framework : Un marco de trabajo, o framework, es una estructura real o conceptual destinada a servir de soporte o gu\u00eda para la construcci\u00f3n de algo que expande la estructura en algo \u00fatil. Para nuestro caso, es mejor que lo veamos como un software pre construido, al que le podemos ir adicionando piezas seg\u00fan sus reglas, con la finalidad obtener un producto personalizado a nuestras necesidades. Patr\u00f3n : Hechos o cosas recurrentes. Estos se repiten con previsibilidad, por lo tanto, pueden funcionar como modelo para producir determinada cosa a partir de ellos. Patr\u00f3n de dise\u00f1o de modelo-vista-controlador (MVC) : Especifica que una aplicaci\u00f3n consta de tres capas: La primera es el modelo de datos, que es la capa con la responsabilidad de la gesti\u00f3n de los datos, luego tenemos la capa de presentaci\u00f3n, es lo que el usuario ve, es decir, la vista. La forma en que la informaci\u00f3n sea presentada al usuario, son responsabilidad de esta capa, por \u00faltimo, tenemos la capa del controlador, que es la capa encargada de orquestar o controlar, la interacci\u00f3n de las dos capas anteriormente mencionadas. Agilidad : Se refiere a la flexibilidad que posee un proyecto, es decir, que pueda cambiar y que esto no produzca un alto impacto en el esfuerzo.","title":"Glosario"},{"location":"uml/lectura/#capitulo-1-introduccion-a-uml","text":"","title":"Cap\u00edtulo 1: Introducci\u00f3n a UML."},{"location":"uml/lectura/#competencias-esperadas","text":"Conocer el lenguaje de modelado unificado (UML). Conocer los distintos tipos de diagramas. Reconocer el paradigma de la programaci\u00f3n en el que est\u00e1 basado UML. Entender el concepto del proceso de creaci\u00f3n de software.","title":"Competencias esperadas."},{"location":"uml/lectura/#que-es-un-modelo","text":"Un modelo, es una representaci\u00f3n de algo, en cierto medio (Papel, pantallas, maquetas, etc.), que capta los aspectos principales, ignorando los menos importantes o que no aporten informaci\u00f3n relevante. Un modelo en un sistema de software est\u00e1 expresado mediante UML.","title":"\u00bfQu\u00e9 es un modelo?"},{"location":"uml/lectura/#que-es-uml","text":"UML (Unified Modeling language), es un lenguaje de modelado unificado, que surge a finales de la d\u00e9cada de los 80 y principios de los 90. Entre los a\u00f1os 94 y 96, Grady y Jim e Ivar, conocidos como; \"los tres amigos\", crearon finalmente UML. Resultado de un trabajo iterativo y gradual, que pone a nuestra disposici\u00f3n, una norma construida sobre muchas ideas y contribuciones realizadas (unificadas), por numerosos individuos y compa\u00f1\u00edas de la comunidad de la orientaci\u00f3n a objetos. UML es un lenguaje y no una metodolog\u00eda , esto suele causar confusiones. Las metodolog\u00edas poseen un lenguaje y un proceso para modelar. En este caso; el lenguaje de modelado es la notaci\u00f3n (gr\u00e1fica), de la que se valen las metodolog\u00edas para expresar los dise\u00f1os.","title":"\u00bfQu\u00e9 es UML?"},{"location":"uml/lectura/#breve-historia","text":"En el a\u00f1o 1980, el paradigma de la orientaci\u00f3n a objetos; ya no era parte solamente del contexto cient\u00edfico, en vez de ello, se encontraba ya en uso \"cotidiano\" en lenguajes que comenzaron a ser ampliamente utilizados como Smalltalk , dando paso a la creaci\u00f3n de nuevos lenguajes basados en en la POO ., como es el caso de C++ . Antes de que todo esto ocurriera, ya exist\u00edan diferentes tipos de metodolog\u00edas para representar el dise\u00f1o de un software utilizando la programaci\u00f3n procedural ; pero ahora hab\u00eda que lograr el mismo \u00e9xito en la POO. Entre los a\u00f1os 90 y el 98, muchas fueron las organizaciones que intentaron llegar a un est\u00e1ndar unificado; pero finalmente \"los tres amigos\", y, su versi\u00f3n 1.1 de UML fueron los ganadores. Tal fue su \u00e9xito, que hasta el d\u00eda de hoy seguimos usando UML como el lenguaje, para representar el dise\u00f1o de artefactos de nuestras aplicaciones.","title":"Breve historia."},{"location":"uml/lectura/#que-tan-rigurosos-debemos-ser-a-la-hora-de-implementar-este-lenguaje","text":"El prop\u00f3sito de UML es ser una herramienta, y, como tal, se debe tener en cuenta que su estricta utilizaci\u00f3n, ir\u00e1 directamente relacionada con el contexto en el que se est\u00e9 trabajando, por ejemplo, si estamos trabajando en una herramienta, que a partir de los modelos que se creen con UML, se genere c\u00f3digo de forma automatizada. Es en este caso, donde usaremos UML de forma rigurosa, para que el c\u00f3digo generado sea el que se necesita. En el caso que se desee utilizar UML en el contexto de una reuni\u00f3n en la que se desee entender un problema y donde los modelos dise\u00f1ados no sean documentados formalmente (por ejemplo en una pizarra en una reuni\u00f3n con el cliente), podemos entonces usar UML con mayor libertad, sin dar tanta importancia a los detalles, sino que basta con que expliquen el problema de una forma global. En este tipo de casos debemos usar lo m\u00ednimo que nos aporte una mejor interpretaci\u00f3n del problema que se desea resolver. Existen ocasiones en que la notaci\u00f3n oficial puede llegar a estorbar, en estos casos no hay que dudar en adaptar el lenguaje a las necesidades personales. Quiz\u00e1s puede ser mal visto el que no estemos usando UML con todas sus sutilezas; pero en este caso ganamos flexibilidad y mientras la comunicaci\u00f3n no se vea afectada, no existe mayor problema en alterar un poco este lenguaje. Hay que tener cuidado al momento de adaptarlo, no nos podemos exceder, ya que el diferir mucho la estructura oficial, puede resultar en que no se comprenda lo que se desee expresar.","title":"\u00bfQu\u00e9 tan rigurosos debemos ser, a la hora de implementar este lenguaje?"},{"location":"uml/lectura/#que-debemos-preguntarnos-antes-de-usar-uml","text":"Ya se ha mencionado que UML lo usamos como una herramienta, y para que lo sea, tenemos que asegurarnos, que la utilizaci\u00f3n de este lenguaje sea \u00fatil . Despu\u00e9s de todo, los diagramas que realizamos pueden ser visualmente atractivos; pero ning\u00fan cliente va a agradecer la belleza de los dise\u00f1os que hemos generados con UML; lo que los clientes, usuarios, stakeholders, etc. quieren son aplicaciones que funcionan. Es por todo esto, que al momento de utilizar UML, debemos hacernos la siguiente pregunta: \u00bfCu\u00e1l ser\u00e1 el beneficio de utilizarlo? y \u00bfC\u00f3mo su uso ayudar\u00e1 al momento de implementar el c\u00f3digo?. Si estas preguntas no tienen una respuesta clara. Entonces, quiz\u00e1s el uso de modelos construidos con UML, no generan un real aporte, que justifiquen su utilizaci\u00f3n.","title":"\u00bfQu\u00e9 debemos preguntarnos antes de usar UML?"},{"location":"uml/lectura/#uml-y-los-paradigmas-de-programacion","text":"El reconocido empresario de las tecnolog\u00edas de la informaci\u00f3n Tom Hadfield , quien a la edad de doce a\u00f1os, cre\u00f3 junto a su padre socckernet (1994) , sitio que fue vendido a ESPN en 40 millones de d\u00f3lares dice: los lenguajes de objetos, permiten ventajas pero no las proporcionan. Para aprovechar estas ventajas hay que realizar el infame cambio de paradigma. (\u00a1S\u00f3lo aseg\u00farese de estar sentado al momento de hacerlo!) La mayor\u00eda de las personas que pod\u00edan reconocer la programaci\u00f3n en esos a\u00f1os e incluso en ahora, la asocia al paradigma de la programaci\u00f3n imperativa. Antes de que el mundo comenzara a utilizar la POO de forma natural, se utilizaba la programaci\u00f3n procedural, y esto era lo usual, lo que sab\u00edamos, por tanto, un cambio en el paradigma supon\u00eda un esfuerzo que queda reflejado en la frase de Hadfield. Entonces estamos ante una herramienta que nos permite modelar, y por ejemplo, por medio de un framework llevar\u00edamos r\u00e1pidamente a c\u00f3digo los diagramas que hemos dise\u00f1ado, si est\u00e1n correctamente dise\u00f1ados por supuesto. Todo esto gracias a que UML fue concebido para la POO. Entonces, \u00bfen qu\u00e9 situaci\u00f3n nos encontramos ahora?. Se podr\u00eda afirmar que un \"nuevo\" paradigma emerge, el paradigma de la programaci\u00f3n declarativa, todo esto debido a que lenguajes como javascript , que toma fuerza en la cantidad de aplicaciones que existentes o que se est\u00e9n desarrollando; pero hay que mencionar que este lenguaje, es un lenguaje funcional (hija del paradigma declarativo), y, adem\u00e1s es un lenguaje imperativo. Entonces nos encontramos ante una mezcla de lo que es programaci\u00f3n funcional y programaci\u00f3n orientada a objetos. Quiz\u00e1s debamos comenzar a comprender que esta mezcla de paradigmas puede coexistir y debemos acostumbrarnos a ello, verlo como una nueva forma de construir, y, no verlo como un dolor de cabeza, hasta que nos acostumbremos a su uso. UML nos seguir\u00e1 sirviendo para representar gr\u00e1ficamente problemas; pero quiz\u00e1s el enfoque cambie un poco, hacia la utilizaci\u00f3n de nuevas herramientas que mezcle lo funcional con lo orientado a objetos. Ver\u00e1n que en librer\u00edas como _React js_ ya utiliza esta mezcla de paradigmas y que cada nueva versi\u00f3n de Java, incluye muchas herramientas que permiten usar la programaci\u00f3n funcional. Como sea que termine esta hist\u00f3ria, UML a\u00fan nos entrega una interfaz entre lo que es abstracto y lo que podr\u00edamos llamar tangible.","title":"UML y los paradigmas de programaci\u00f3n."},{"location":"uml/lectura/#el-proceso-de-desarrollo-de-software","text":"UML, es un lenguaje para modelar, por eso no asume la noci\u00f3n de un proceso; pero para poder realizar un buen desarrollo, hay que analizar el propio proceso de desarrollar aplicaciones. Una visi\u00f3n del desarrollo en su nivel m\u00e1s alto ser\u00eda como la que muestra la figura 1.1. Figura 1.1: Proceso de desarrollo de software. Durante la concepci\u00f3n, se establece la raz\u00f3n de ser del proyecto, adem\u00e1s del alcance del mismo. Es en esta etapa en donde se define si el proyecto se realiza o no. En la elaboraci\u00f3n, se detallan m\u00e1s profundamente los requerimientos, para as\u00ed llegar a confeccionar una arquitectura base. Los dise\u00f1os utilizados han de ser de alto nivel, es decir, sin gran nivel de detalle, destacando solamente lo principal. Dependiendo del nivel de agilidad del proyecto, esta etapa puede ser desde una reuni\u00f3n de un par de horas, hasta una entrega de documentos formales, con iteraciones. Al finalizar esta etapa, las preguntas: \u00bfQu\u00e9 es lo que va a construir en realidad?, \u00bfC\u00f3mo lo va a construir?, \u00bfQu\u00e9 tecnolog\u00eda emplear\u00e1?, deben ser contestadas. En la construcci\u00f3n, como se indica en la figura 1.1, la iteraci\u00f3n es clave. No quiere decir que el las otras etapas no se pueda iterar; pero en esta etapa, cada iteraci\u00f3n es un mini proyecto. Terminando con una demostraci\u00f3n funcional al stakeholder. Con ello reducimos el riesgo, ya que si algo no ha salido como se quer\u00eda, solamente est\u00e1 en juego la iteraci\u00f3n y no el proyecto completo. La funcionalidad ser\u00e1 incremental y la construcci\u00f3n de c\u00f3digo ser\u00e1 iterativa. \u00bfCu\u00e1ndo se debe usar el desarrollo iterativo? El desarrollo iterativo \u00fanicamente se debe utilizar en aquellos proyectos que se quiere que tengan \u00e9xito. Todas las t\u00e9cnicas de UML son \u00fatiles durante esta etapa; pero hay que ser cuidadosos, de no excedernos, como dice la siguiente cita: Los memorandos cuidadosamente escritos y seleccionados, pueden sustituir con toda facilidad a la tradicional documentaci\u00f3n detallada del dise\u00f1o. Esta \u00faltima es sobresaliente en pocas ocasiones, excepto en algunos puntos aislados. Destaque estos puntos... y olv\u00eddese del resto.. \"Ward Cunningham (1996)\" Durante la transici\u00f3n, no se hacen desarrollos para a\u00f1adir funciones nuevas (a menos que sean peque\u00f1as y absolutamente indispensables). Ciertamente, s\u00ed hay desarrollo para depuraci\u00f3n. Un buen ejemplo de una fase de transici\u00f3n es el tiempo entre la liberaci\u00f3n beta y ]a liberaci\u00f3n definitiva del producto.","title":"El proceso de desarrollo de software."},{"location":"uml/lectura/#tipos-de-diagramas-en-uml","text":"No existe una l\u00ednea que divida claramente UML; pero podemos reconocer los diferentes tipos de diagramas, para poder apreciar el aspecto del sistema que se intenta representar. Tipos Estructurales Diagrama de clases. Diagrama de paquetes. Diagrama de objetos. Diagrama de componentes. Diagrama de estructura compuesta. Diagrama de despliegue. Tipos comportamiento. Diagrama de actividad. Diagrama de secuencia. Diagrama de casos de uso. Diagrama de estado. Diagrama de comunicaci\u00f3n. Diagrama de interacci\u00f3n. Diagrama de sincronizaci\u00f3n. Los diagramas que est\u00e1n destacados, se detallar\u00e1n en los cap\u00edtulos posteriores. Esto no se debe a que los dem\u00e1s no sirvan o sean menos importantes, m\u00e1s bien, se trata de poder utilizar lo mejor de UML, para resolver la mayor\u00eda de los problemas de dise\u00f1o de software. \"De verdad, s\u00f3lo necesitas un 20% del UML, para modelar el 80% del dise\u00f1o que necesitar\u00e1s en un proyecto \u2013 \u00e1gil o no\". - Grady Booch.","title":"Tipos de diagramas en UML."},{"location":"uml/lectura/#capitulo-2-los-casos-de-uso","text":"","title":"Cap\u00edtulo 2: Los casos de uso."},{"location":"uml/lectura/#21-competencias-esperadas","text":"Comprender el concepto de casos de uso. Construir caso de uso. Identificar los casos de uso, para una problem\u00e1tica y representarla con la notaci\u00f3n UML.","title":"2.1 Competencias esperadas."},{"location":"uml/lectura/#22-introduccion","text":"Durante mucho tiempo, cuando era utilizado el paradigma procedural de forma popular, incluso cuando la POO comenzaba a ser muy conocida y utilizada. Los escenarios eran representados de forma muy r\u00fastica. las personas se auxiliaban de escenarios t\u00edpicos que les ayudaban a comprender los requerimientos. Muchas veces se constru\u00edan; pero no se documentaban, Ivar Jacobson, uno de los tres creadores de UML, elev\u00f3 la visibilidad del caso de uso (su nombre para un escenario) a tal punto, que lo convirti\u00f3 en un elemento primario de la planificaci\u00f3n y el desarrollo de proyectos de software.","title":"2.2 Introducci\u00f3n."},{"location":"uml/lectura/#23-diagramas-de-casos-de-uso","text":"En el a\u00f1o 1994, Jacobson no solo logr\u00f3 introducir los casos de uso como un concepto para ayudar en los primeros pasos del desarrollo de aplicaciones, adem\u00e1s, desarrollo una representaci\u00f3n gr\u00e1fica de este hecho y lo llam\u00f3 El Diagrama de Casos de Uso , y este diagrama ahora forma parte de UML. Una representaci\u00f3n de un diagrama de casos de uso ser\u00eda el siguiente: Figura 2.1: Diagrama de casos de uso b\u00e1sico.","title":"2.3 Diagramas de casos de uso."},{"location":"uml/lectura/#231-casos-de-uso-cu","text":"Un caso de uso es, en esencia, una interacci\u00f3n t\u00edpica entre un usuario y un sistema de software . considere la aplicaci\u00f3n con la que se escriben estas l\u00edneas que usted lee. Dos casos de uso t\u00edpicos ser\u00edan \"poner una parte del texto en negritas\" y \"Borrar el texto seleccionado\". Por medio de estos ejemplos, se puede uno dar una idea de ciertas propiedades de los casos de uso. Figura 2.2: Notaci\u00f3n de un caso de uso. Capta alguna funci\u00f3n visible para el usuario. Puede ser peque\u00f1o o grande. Logra un objetivo discreto para el usuario. Usualmente, el caso de uso se extrae de las interacciones, que los potenciales usuarios del sistema tengan con la aplicaci\u00f3n que se desee construir. Cada una de estas, se debe abordar de forma discreta, darle un nombre y escribir una breve descripci\u00f3n. No hay que detallar tan profundamente esta interacci\u00f3n, todo esto dependiendo de la cantidad de ramificaciones, de las que est\u00e9 compuesto el caso de uso, se podr\u00e1 m\u00e1s adelante obtener mayores detalles que pueden resultar en nuevos casos de uso. Objetivos del usuario vs interacciones con el sistema: Cuando se est\u00e1n tomando los requerimientos, a veces es f\u00e1cil confundirse entre los objetivos que el usuario tiene y las interacciones que har\u00e1 con el sistema . Supongamos el desarrollo de un sistema de ventas. Surgir\u00e1n interacciones como: \"Ingresar un producto\", \"actualizar precio\". etc. Esto difiere de los objetivos que pueda tener el usuario como, \"mantener la informaci\u00f3n de los precios actualizada\", \"Garantizar que est\u00e9 disponible la informaci\u00f3n de los productos\". En ambos casos tenemos requerimientos del usuario, pero la granularidad es diferente, ya que las interacciones son m\u00e1s sencillas de implementar que los objetivos. Cuando estamos reuniendo los casos de uso del sistema, debemos mantener una granularidad m\u00e1s o menos similar, es decir, el nivel de detalle y complejidad de cada caso de uso, debe ser similar. Finalmente como lo definimos, mantendremos el foco de la captura de los casos de uso, centradas en las interacciones, sin perder de vista los objetivos, en el caso que s\u00f3lo tengamos los objetivos del usuario, debemos granular esta informaci\u00f3n, en interacciones necesarias para que se cumplan los objetivos. Como recomendaci\u00f3n, es bueno tener varios casos de uso por objetivo, al menos los objetivos principales, ya que en las iteraciones que vayamos haciendo, se recibe mucho mejor que el usuario vea como se van cumpliendo sus objetivos (aunque lo m\u00e1s probable es que estos objetivos vayan evolucionando a medida que el sistema avanza).","title":"2.3.1 Casos de uso (CU)"},{"location":"uml/lectura/#232-actores","text":"Empleamos el t\u00e9rmino actor para llamar as\u00ed al usuario, cuando desempe\u00f1a ese papel con respecto al sistema. Los actores llevan a cabo casos de uso. Un mismo actor puede realizar muchos casos de uso; a la inversa, un caso de uso puede ser realizado por varios actores. No es necesario que los actores sean seres humanos , a pesar de que los actores est\u00e9n representados por figuras humanas. El actor puede ser tambi\u00e9n un sistema externo que necesite cierta informaci\u00f3n del sistema actual Figura 2.3: Notaci\u00f3n de un actor.","title":"2.3.2 Actores"},{"location":"uml/lectura/#233-relaciones","text":"UML define cuatro tipos de relaciones en los diagramas de casos de uso: Comunicaci\u00f3n Esta relaci\u00f3n es la que m\u00e1s veremos en los CU, como estereotipo se representa por < > ; pero generalmente este estereotipo no va escrito. Es una relaci\u00f3n de asociaci\u00f3n que nos muestra la interacci\u00f3n entre un actor y el caso de uso. Figura 2.4: Relaci\u00f3n de comunicaci\u00f3n de asociaci\u00f3n.","title":"2.3.3 Relaciones"},{"location":"uml/motivaciOn/","text":"Motivaci\u00f3n La lengua com\u00fan. En el desarrollo de software, tenemos que sortear una serie de obst\u00e1culos, pero sin duda uno de los m\u00e1s importantes, es el de construir el software que satisfaga \"adecuadamente\", las necesidades de los usuarios; a un costo \"adecuadamente razonable\". Nos preguntamos entonces, \u00bfPor qu\u00e9 es tan complicado?. En t\u00e9rminos de comunicaci\u00f3n, cuando visitamos a un m\u00e9dico o si llevamos a nuestras mascotas al veterinario, para las personas que no estudiamos las ciencias de la salud, nos resulta complicado comprender, a veces, lo que dice el especialista, imaginemos que le debemos decir, exactamente lo que queremos que haga. Suena un poco dif\u00edcil, si hasta decir que corte de cabello queremos, nos resulta (al menos a mi), una tarea no tan sencilla de realizar, adem\u00e1s, no siempre resulta como lo pedimos, y, en la mayor\u00eda de las veces, simplemente aceptamos el trabajo que nos hicieron, depositando las esperanzas en que volver\u00e1 a crecer y tendremos una nueva oportunidad. Nuestro trabajo, es muy bien valorado por aquellas personas que deseen automatizar lo m\u00e1s que se pueda sus procesos, ellos conocen muy bien lo que hacen; pero nosotros no tenemos por qu\u00e9 saberlo. Tambi\u00e9n conocemos bien lo que hacemos; pero los dem\u00e1s no tienen por qu\u00e9 saberlo, es entonces cuando se necesita un lenguaje com\u00fan, donde mediante los modelos que nos propone UML, se logra unir estos dos mundos, logrando una mejor comunicaci\u00f3n, logrando que lo que construyamos, sea lo m\u00e1s \"adecuado\" posible a lo que se quiere. El plano general. Una tarea recurrente en el \u00e1rea del desarrollo, es enfrentarse a proyectos que ya llevan un tiempo implement\u00e1ndose. En este tipo de situaciones, entender como est\u00e1 constru\u00eddo y para qu\u00e9 fue constru\u00eddo, es decir, qu\u00e9 problema de negocio est\u00e1 resolviendo, ser\u00e1 mucho m\u00e1s sencillo si se ha utilizado UML en su implementaci\u00f3n. Con UML podemos ver desde qu\u00e9 nivel de abstracci\u00f3n posee la aplicaci\u00f3n, hasta complejos procesos de negocio de la empresa. UML es una herramienta que resuelve, de forma transversal, la tarea de automatizaci\u00f3n mediante el desarrollo de aplicaciones.","title":"Motivaci\u00f3n"},{"location":"uml/motivaciOn/#motivacion","text":"","title":"Motivaci\u00f3n"},{"location":"uml/motivaciOn/#la-lengua-comun","text":"En el desarrollo de software, tenemos que sortear una serie de obst\u00e1culos, pero sin duda uno de los m\u00e1s importantes, es el de construir el software que satisfaga \"adecuadamente\", las necesidades de los usuarios; a un costo \"adecuadamente razonable\". Nos preguntamos entonces, \u00bfPor qu\u00e9 es tan complicado?. En t\u00e9rminos de comunicaci\u00f3n, cuando visitamos a un m\u00e9dico o si llevamos a nuestras mascotas al veterinario, para las personas que no estudiamos las ciencias de la salud, nos resulta complicado comprender, a veces, lo que dice el especialista, imaginemos que le debemos decir, exactamente lo que queremos que haga. Suena un poco dif\u00edcil, si hasta decir que corte de cabello queremos, nos resulta (al menos a mi), una tarea no tan sencilla de realizar, adem\u00e1s, no siempre resulta como lo pedimos, y, en la mayor\u00eda de las veces, simplemente aceptamos el trabajo que nos hicieron, depositando las esperanzas en que volver\u00e1 a crecer y tendremos una nueva oportunidad. Nuestro trabajo, es muy bien valorado por aquellas personas que deseen automatizar lo m\u00e1s que se pueda sus procesos, ellos conocen muy bien lo que hacen; pero nosotros no tenemos por qu\u00e9 saberlo. Tambi\u00e9n conocemos bien lo que hacemos; pero los dem\u00e1s no tienen por qu\u00e9 saberlo, es entonces cuando se necesita un lenguaje com\u00fan, donde mediante los modelos que nos propone UML, se logra unir estos dos mundos, logrando una mejor comunicaci\u00f3n, logrando que lo que construyamos, sea lo m\u00e1s \"adecuado\" posible a lo que se quiere.","title":"La lengua com\u00fan."},{"location":"uml/motivaciOn/#el-plano-general","text":"Una tarea recurrente en el \u00e1rea del desarrollo, es enfrentarse a proyectos que ya llevan un tiempo implement\u00e1ndose. En este tipo de situaciones, entender como est\u00e1 constru\u00eddo y para qu\u00e9 fue constru\u00eddo, es decir, qu\u00e9 problema de negocio est\u00e1 resolviendo, ser\u00e1 mucho m\u00e1s sencillo si se ha utilizado UML en su implementaci\u00f3n. Con UML podemos ver desde qu\u00e9 nivel de abstracci\u00f3n posee la aplicaci\u00f3n, hasta complejos procesos de negocio de la empresa. UML es una herramienta que resuelve, de forma transversal, la tarea de automatizaci\u00f3n mediante el desarrollo de aplicaciones.","title":"El plano general."},{"location":"uml/quizzes/","text":"Quizzes Cap\u00edtulo 1: Introducci\u00f3n a UML Pregunta 1: \u00bfQu\u00e9 es UML? A - Un est\u00e1ndar gr\u00e1fico, para la representaci\u00f3n de modelos de un sistema de software. B - Un lenguaje gr\u00e1fico, para la representaci\u00f3n de modelos de un sistema de software. C - A y B, son correctas. E - Ninguna de las anteriores. Respuesta correcta: B. Pregunta 2: \u00bfA qu\u00e9 tipo de diagrama, pertenece el diagrama de casos de uso? A - Estructural. B - Comportamiento. C - Funcional. D - A y B, son correctas. E - A y C, son correctas. Respuesta correcta: B. Pregunta 3: \u00bfCual de las siguientes afirmaciones es Verdadera? A - Estructural, NO es un tipo de diagrama. B - Comportamiento, es un tipo de diagrama. C - Funcional, es un tipo de diagrama. D - Comportamiento, NO es un tipo de diagrama. Respuesta correcta: B. Pregunta 4: Respecto al uso de UML. \u00bfCual de las siguientes afirmaciones es Verdadera? A - Se debe detallar, muy profundamente en los diagramas que se realicen con UML. B - Antes de comenzar a codificar, es obligaci\u00f3n que utilicemos los diagramas UML. C - Mientras m\u00e1s modelos tengamos, menos tiempo nos tomar\u00e1 la construcci\u00f3n de la aplicaci\u00f3n. D - Podemos usar UML, para lograr una idea de la arquitectura que queremos y con esto es suficiente. E - Todas las alternativas, son correctas. Respuesta correcta: D. Pregunta 5: \u00bfEn qu\u00e9 paradigma de programaci\u00f3n, se basan los diagramas de UML? A - Programaci\u00f3n orientada a objetos. B - Programaci\u00f3n funcional. C - Programaci\u00f3n declarativa. Respuesta correcta: A. Pregunta 6: El proceso de desarrollo de software, contempla los siguientes pasos: A - Concepci\u00f3n, elaboraci\u00f3n, transici\u00f3n. B - Elaboraci\u00f3n, construcci\u00f3n, transici\u00f3n. C - Construcci\u00f3n, transici\u00f3n. D - Concepci\u00f3n, elaboraci\u00f3n, construcci\u00f3n, transici\u00f3n. Respuesta correcta: D.","title":"Quizzes"},{"location":"uml/quizzes/#quizzes","text":"","title":"Quizzes"},{"location":"uml/quizzes/#capitulo-1-introduccion-a-uml","text":"","title":"Cap\u00edtulo 1: Introducci\u00f3n a UML"},{"location":"uml/quizzes/#pregunta-1-que-es-uml","text":"A - Un est\u00e1ndar gr\u00e1fico, para la representaci\u00f3n de modelos de un sistema de software. B - Un lenguaje gr\u00e1fico, para la representaci\u00f3n de modelos de un sistema de software. C - A y B, son correctas. E - Ninguna de las anteriores. Respuesta correcta: B.","title":"Pregunta 1: \u00bfQu\u00e9 es UML?"},{"location":"uml/quizzes/#pregunta-2-a-que-tipo-de-diagrama-pertenece-el-diagrama-de-casos-de-uso","text":"A - Estructural. B - Comportamiento. C - Funcional. D - A y B, son correctas. E - A y C, son correctas. Respuesta correcta: B.","title":"Pregunta 2: \u00bfA qu\u00e9 tipo de diagrama, pertenece el diagrama de casos de uso?"},{"location":"uml/quizzes/#pregunta-3-cual-de-las-siguientes-afirmaciones-es-verdadera","text":"A - Estructural, NO es un tipo de diagrama. B - Comportamiento, es un tipo de diagrama. C - Funcional, es un tipo de diagrama. D - Comportamiento, NO es un tipo de diagrama. Respuesta correcta: B.","title":"Pregunta 3: \u00bfCual de las siguientes afirmaciones es Verdadera?"},{"location":"uml/quizzes/#pregunta-4-respecto-al-uso-de-uml-cual-de-las-siguientes-afirmaciones-es-verdadera","text":"A - Se debe detallar, muy profundamente en los diagramas que se realicen con UML. B - Antes de comenzar a codificar, es obligaci\u00f3n que utilicemos los diagramas UML. C - Mientras m\u00e1s modelos tengamos, menos tiempo nos tomar\u00e1 la construcci\u00f3n de la aplicaci\u00f3n. D - Podemos usar UML, para lograr una idea de la arquitectura que queremos y con esto es suficiente. E - Todas las alternativas, son correctas. Respuesta correcta: D.","title":"Pregunta 4: Respecto al uso de UML. \u00bfCual de las siguientes afirmaciones es Verdadera?"},{"location":"uml/quizzes/#pregunta-5-en-que-paradigma-de-programacion-se-basan-los-diagramas-de-uml","text":"A - Programaci\u00f3n orientada a objetos. B - Programaci\u00f3n funcional. C - Programaci\u00f3n declarativa. Respuesta correcta: A.","title":"Pregunta 5: \u00bfEn qu\u00e9 paradigma de programaci\u00f3n, se basan los diagramas de UML?"},{"location":"uml/quizzes/#pregunta-6-el-proceso-de-desarrollo-de-software-contempla-los-siguientes-pasos","text":"A - Concepci\u00f3n, elaboraci\u00f3n, transici\u00f3n. B - Elaboraci\u00f3n, construcci\u00f3n, transici\u00f3n. C - Construcci\u00f3n, transici\u00f3n. D - Concepci\u00f3n, elaboraci\u00f3n, construcci\u00f3n, transici\u00f3n. Respuesta correcta: D.","title":"Pregunta 6: El proceso de desarrollo de software, contempla los siguientes pasos:"}]}